#!/usr/bin/env python3
#
# +!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#                                                                       #
#                                 triangle2adcirc.py                    # 
#                                                                       #
# +!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#
# Author: Pat Prodanovic, Ph.D., P.Eng., modularized by Sebastian Schwindt
#
# Date: June 26, 2016 / July 22, 2022

import numpy as np


def CCW(x1, y1, x2, y2, x3, y3):
    return (y3 - y1) * (x2 - x1) > (y2 - y1) * (x3 - x1)


def triangle2adcirc(nodes_file="out.1.node", elements_file="out.1.ele", output_file="out.grd"):
    """ Function takes files generated by triangle mesh generator, and converts them to an ADCIRC mesh format

  :param str nodes_file: full path to and name of nodes CSV file. The nodes file consist of x,y,z or x,y,z,size; The
                          size parameter is an optional input, and is used by gmsh as an extra parameter that forces
                          an element size around particular nodes (not relevant for triangle). The nodes file must be
                          comma separated, and have no header lines.
  :param str elements_file: elements file generated by triangle
  :param str output_file: output adcirc mesh file
  :return:
  """
    # to create the output file
    fout = open(output_file, "w")

    # use numpy to read the file
    # each column in the file is a row in data read by no.loadtxt method
    nodes_data = np.genfromtxt(nodes_file, skip_header=1, comments="#", unpack=True)
    elements_data = np.genfromtxt(elements_file, skip_header=1, comments="#", unpack=True)

    # nodes in the input file
    node_id = nodes_data[0, :]
    node_id = node_id.astype(np.int32)
    x = nodes_data[1, :]
    y = nodes_data[2, :]
    z = nodes_data[3, :]

    # elements in the input file
    element_id = elements_data[0, :]
    element_id = element_id.astype(np.int32)
    e1 = elements_data[1, :]
    e1 = e1.astype(np.int32)
    e2 = elements_data[2, :]
    e2 = e2.astype(np.int32)
    e3 = elements_data[3, :]
    e3 = e3.astype(np.int32)

    # make sure the elements are oriented in CCW fashion

    ikle = np.column_stack((e1, e2, e3))

    # go through each element, and make sure it is oriented in CCW fashion

    for i in range(len(ikle)):

        # if the element is not CCW then must change its orientation
        if not CCW(x[ikle[i, 0] - 1], y[ikle[i, 0] - 1], x[ikle[i, 1] - 1], y[ikle[i, 1] - 1],
                   x[ikle[i, 2] - 1], y[ikle[i, 2] - 1]):
            t0 = ikle[i, 0]
            t1 = ikle[i, 1]
            t2 = ikle[i, 2]

            # switch orientation
            ikle[i, 0] = t2
            ikle[i, 2] = t0
    # #######################

    # now to write the adcirc mesh file
    fout.write("ADCIRC" + "\n")
    # writes the number of elements and number of nodes in the header file
    fout.write(str(len(element_id)) + " " + str(len(node_id)) + "\n")

    # writes the nodes
    for i in range(0, len(node_id)):
        fout.write(str(node_id[i]) + " " + str("{:.3f}".format(x[i])) + " " +
                   str("{:.3f}".format(y[i])) + " " + str("{:.3f}".format(z[i])) + "\n")

    # writes the elements
    for i in range(0, len(element_id)):
        fout.write(str(element_id[i]) + " 3 " + str(ikle[i, 0]) + " " + str(ikle[i, 1]) + " " +
                   str(ikle[i, 2]) + "\n")
